# 先知大数据
1. 三种清除浮动的方法。浮动的表现形式
2. 三种隐藏元素的方法
3. 垂直居中
4. instanceof的用法，基本类型的变量或常量instanceof类型
5. this的用法
6. es6是否了解。介绍Promise
7. css选择器的权重
8. 不同浏览器兼容问题
9. 模块的引入
10. 状态码
11. Restful有几种
12. vue的虚拟DOM与实体DOM的区别
13. vue2与vue3的区别
14. 字符串用的最多的方法
15. vue是单向数据流还是双向的
16. vue的生命周期（感觉就是问vue实例生成的过程，问的不清不楚的）
17. vue的命令
18. computed和watch的区别
19. vue的class如何绑定
20. vue-router权限路由的实现
21. keep-alive
22. v-model
23. web页面优化
24. 问了sass会不会
25. js的基本类型
26. position的absolute、relative、fixed、static区别
27. Promise的用法，也就是宏任务微任务的先后顺序
28. http头中影响缓存的字段

感觉不认识element这个框架啊。node.js的经典express.js还要介绍？用主要使用React来做借口感觉不行啊。问sass会不会的时候，我本身是不会的，我说是css预编译吗？不知道是不是没听清还是听不懂，又重复了一遍。还得学多点组件，看多点框架，但是看多了你应聘的公司又不用有什么用呢？

1. 使用overflow:hidden或auto清除浮动，应该就是设置BFC来清除浮动。在元素之后的元素，使用clear属性来清除，使用了clear清除左右的浮动。父元素设置浮动也能清除子元素浮动。可以使用::after或::before这些伪元素使用clear来清除浮动。浮动就是脱离文档流但没脱离文本流，会产生文字环绕，父元素高度坍塌之类效果。很多ui库都因为float的问题转而使用flex来进行排版。
2. display:none;opacity:0;visibility:hidden;{position:absolute;left:-999;top:-999};clip-path:polygon(0px 0px,0px 0px,0px 0px,0px 0px);
3. 使用position:absolute来居中（父元素width、height明确）。line-height与height一致（只能一行居中）。display:table-cell/inline-block;vertical-align:middle;。display:flex;align-self:center;父元素的伪类使用vertical-align也可以居中。使用transform变形。设置隐藏节点在前，高度为剩余高度的一半。设置padding的上下内边距，都为0，应该可以。
4. Object instanceof constructor;判断一个引用是否属于构造函数。就是一直从原型链往下找。
![原型链](https://img-blog.csdnimg.cn/20190311193622793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjMTg4Njg4NzY4Mzc=,size_16,color_FFFFFF,t_70#pic_center)
```JavaScript
'str' instanceof String//false
123 instanceof Number//false
[1,2,3] instanceof Array//true
[1,2,3] instanceof Object//true
(function(){}) instanceof Function//true
(function(){}) instanceof Object//true
```
5. this在一般函数中就代表全局。作为对象方法调用的话，this代表上级对象。作为构造方法调用，this指代new出的对象。apply调用，此方法的第一个参数为改变后调用这个函数的对象，this指代第一个参数。
6. 讲讲es6的东西。介绍一下Promise。Promise（异步回调）的三个状态：pending（等待）、fulfilled(成功)、rejected（失败）
7. 优先级：!Important>行内样式>ID选择器>类选择器>元素>通配符>继承>浏览器默认属性
8. 先把默认的样式比如margin、padding给置0再重新设置样式。使用moz、khtml、webkit等私有属性。用hack
9. `require`、`import`、`<script>`
10. 1**：信息，服务器收到请求，需要请求者继续执行操作。2**：成功，操作被成功接收并处理。3**：重定向，需要进一步的操作完成请求。4**：客户端错误，请求包含语法错误或无法完成请求。5**：服务器错误，服务器处理请求的过程中发生了错误。常见状态码：200:请求成功。301:资源被永久转移到其他URL。404:请求的资源不存在。500:内部服务器错误。
11. Restful分为GET､ POST､ DELETE、PUT4种操作方式。GET表示获取资源，POST表示新建资源，PUT表示更新资源DELETE表示删除资源。
12. 虚拟DOM不会进行排版与重绘操作，虚拟DOM就是把真实DOM转换为Javascript代码，就类似于用innerHtml获取到的element对象。虚拟DOM修改后与真实DOM比较进行修改，这样真实DOM根据修改的部分进行排版与重绘，减少过多DOM节点排版和重绘损耗。真实DOM频繁排版与重绘的效率是相当低的。虚拟DOM有效降低大面积（真实DOM节点）的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部。使用虚拟DOM的损耗计算：总损耗 = 虚拟DOM增删改 + （与Diff算法效率有关）真实DOM差异增删改 + （较少的节点）排版与重绘。直接使用真实DOM的损耗计算：总损耗 = 真实DOM完全增删改 + （可能较多的节点）排版与重绘。
13. vue2.0的数据响应是用`Object.defineProperty`来遍历对象中的数据来设置`setter/getter`，而vue3.0是使用`proxy`来监听整个对象。vue3.0可拦截apply、ownKeys、has等13种方法，而`Object.defineProperty`不行。可以直接实现对象的新增、删除，因为使用`ObjectdefineProperty`的话，是在一开始初始化的时候设置`setter/getter`，后续新增的话不会设置`getter/setter`，删除对象的话不会监听到。数组不能直接监听，要改变数组形式。可以按需加载，vue2在new一个实例的时候，会将全部组件功能，不管用没用都会加载，vue3可以按需引用。懒观察：vue2会在一开始就创建`watcher`，而vue3被用于初始渲染可视部分的数据创建`watcher`。更精准的变更通知：vue2使用`Vue.set`给对象新增一个新属性时，所有`watcher`都需要重新运行，vue3只有依赖于该属性的`watcher`才会重新运行。vue3支持Typescript和PWA的支持。vue2和vue3的组件开发发生改变：单文件组件中，vue2只能有一个根节点，vue3可以有多个根节点。vue2获取数据可以直接获取，vue3要使用state，类似vuex，数据都存在state中，vue2:`{{data}}`、vue3：`{{state.data}}`。Vue2使用选项类型API（Options API）、Vue3合成型API（Composition API）。vue2分割了data、methods、computed等等，vue3是使用一个setup方法包裹了data等模块:`state=reactive({data:'data'})`。就是说setup方法返回一个对象，对象有属性、方法。vue2生命周期的钩子函数是单独存在的，vue3是将其放在setup中。vue2的computed是单独模块，vue3是跟data的对象一起，使用computed方法，计算一个属性，放在state中：`state=reactive({test:computed(()=>{return 'test})})`。vue2的this代表这个组件，props可以使用this来直接使用，但vue3不代表了，不能直接使用，只能用`context`：`emit`、`slots`、`attrs`这几个，但setup方法可以接收props和`context`这两个参数，可以使用props，vue2可以使用`this.$emit`来自定义方法，vue3通过setup接收emit来使用。重构虚拟树。
14. 


